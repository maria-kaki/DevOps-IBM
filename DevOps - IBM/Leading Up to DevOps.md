![[Pasted image 20230615205438.png]]
![[Pasted image 20230615205608.png]]
![[Pasted image 20230615205754.png]]
#### Requirements are gathered and a requirements document is generated. Then that phase ends. The artifacts for that phase flow down into the next one. In the next phase, we do all the design and the design is documented in high-level designs, low-level designs, system-level designs, and then that phase ends. Those artifacts get passed down to the next phase and the coding begins where developers take the low-level design documents and write the code that implements those designs. There are entrance and exit criteria to each of the phases. So, all along, we're coding in isolation, we're not integrating my module with the next person's module. Finally, you get to the integration phase when all those modules come together. This is the first time we realize, we don’t know whether all these pieces even work together. And then we move on to the testing phase, because now we've got a system that people can test. And as they find bugs, they must go swim back, up the waterfall, and open some bugs in the coding phase and do some re-coding. Finally, after all the testing, we deploy the software. It is called Waterfall because if there is a problem, it is very hard to go back, like trying to swim up a waterfall. You have to go all the way back to the design phase. In fact, because we treat software development like civil engineering projects, sometimes some of those architects have moved on to the next project, and you've got to go find them and then get them to change the design. You get the developers to change the code and hope that it integrates this time. This process was very error prone and there was no room for making changes late in the process. You didn't know whether it worked until the end, so it was very high risk. But we developed software like this for years.
![[Pasted image 20230616010516.png]]
![[Pasted image 20230616010541.png]]
![[Pasted image 20230616010609.png]]




